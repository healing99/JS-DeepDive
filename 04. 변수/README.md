<img src="https://velog.velcdn.com/images/yoonvelog/post/6657a330-5565-43f5-a928-9ff1ff4846ae/image.png" width="680" height="400"/>

## 4.1 변수란 무엇인가? 왜 필요한가?

**변수**는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다. <br/>
아래와 같은 자바스크립트 코드를 실행하면 컴퓨터에서 어떤 일이 일어날까?

```
10+20
```

자바스크립트 엔진이 위 코드를 계산(평가, evaluation) 하려면 먼저 `10`, `20`, `+` 라는 기호(리터럴 literal과 연산자 operator)의 의미를 알고 있어야 하며, `10+20` 이라는 식(표현식 expression)의 의미도 해석(파싱 parsing) 할 수 있어야한다.<br/>

컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다. <br/>
메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다. (메모리 셀 하나의 크기는 1byte = 8bit) <br/>
컴퓨터는 메모리 셀의 크기, 즉 1byte 단위로 데이터를 저장하거나 읽어들인다.<br/>

각 셀은 고유의 메모리 주소(memory address)를 갖는다.<br/>
이 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표시된다.<br/>

컴퓨터는 모든 데이터를 2진수로 처리한다. <br/>
따라서 메모리에 저장되는 데이터는 데이터의 종류(숫자, 텍스트, 이미지, 동영상 등)와 상관없이 모두 2진수로 저장된다.<br/>

---

다시 예제로 돌아가서, `10+20` 연산이 성공적으로 끝나 결과 값 30이 메모리에 저장되었지만 문제가 있다.<br/>
`10+20`이라는 연산을 했다는 것은 그 연산 결과가 필요하고 이를 사용해 무언가를 하겠다는 의도가 있었을텐데, <br/>
연산 결과 `30`을 재사용하고 싶은 경우 `30`이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다.<br/>

하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 크다.<br/> 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.<br/>

추가적으로, 값이 저장될 메모리 주소는 코드가 실행될 때 메모리의 상황에 따라 임의로 결정된다.<br/>
따라서 동일한 컴퓨터에서 동일한 코드를 실행해도 코드가 실행될 때마다 값이 저장될 메모리 주소는 변경된다.<br/>
따라서 메모리 주소를 통해 직접 접근하는 것은 올바른 방법이 아니다.<br/>

프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 **변수**라는 메커니즘을 제공한다.<br/>

> 변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. <br/>
> 간단히 말해, 값의 위치를 가리키는 상징적인 이름이다.

상징적 이름인 변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.<br/>
따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다.<br/>

앞선 코드를 변수를 사용해 다시 작성해보자.

```
var result = 10 + 20;
```

변수에 값을 저장하는 것을 **할당(= assignment, 대입, 저장)** 이라 하고, 변수에 저장된 값을 읽어 들이는 것을 **참조(= reference)** 라고 한다. <br/>

변수에 저장된 값의 의미를 파악할 수 있는 변수 이름은 가독성을 높이는 부수적인 효과가 있다.<br/>

코드는 컴퓨터에게 내리는 명령이지만 개발자를 위한 문서이기도 하다.<br/>
개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며, 이는 협업과 품질 향상에 도움을 준다.<br/> 변수 이름은 심사숙고해서 지어야한다.<br/>

## 4.2 식별자

변수 이름을 식별자(identifier)라고도 한다.<br/>
**식별자**는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.<br/>

값은 메모리 공간에 저장되어 있다.<br/>
따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야한다. <br/>
이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야한다.<br/>
즉, 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며 이 매핑 정보도 메모리에 저장되어야한다.<br/>

이처럼 **식별자는 값이 아니라 메모리 주소를 기억**하고 있다.<br/>
식별자는 메모리 주소에 붙인 이름이라고 생각하면 쉽다.<br/>

식별자라는 용어는 변수 이름에만 국한해서 사용하지 않는다. <br/>
변수, 함수, 클래스 등의 이름 또한 모두 식별자이며 즉 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.<br/>

변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야하며 **선언(declaration)에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.** <br/>

## 4.3 변수 선언

**변수 선언(variable declaration)** 이란 **변수를 생성하는 것**을 의미한다. <br/>
값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것이다.<br/>
변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.<br/>

**변수를 사용하려면 반드시 선언이 필요하다.**<br/>
변수 선언 시 var, let, const 키워드를 사용한다.<br/>

[변수 선언문]<br/>

```ts
var count;
```

변수를 선언한 이후 아직 변수에 값을 할당하지 않았다. <br/>
확보된 메모리 공간이 비어있을 것이라고 생각할 수 있지만, 확보된 메모리 공간에는 자바스크립트 엔진에 의해 **undefined**라는 값이 암묵적으로 할당되어 초기화된다.<br/> (undefined는 자바스크립트에서 제공하는 원시 타입의 값이다)

자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행한다.<br/>

1\) 선언 단계 : 변수 이름을 등록해서 자바스립트 엔진에 변수의 존재를 알린다 <br/>
2\) 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화한다

`var` 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다.<br/>
위의 예시에서 선언 단계를 통해 변수 이름 count를 등록하고, 초기화 단계를 통해 count 변수에 암묵적으로 undefined를 할당해 초기화한다.<br/>

만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. (쓰레기 값 = garbage value) <br/>
따라서 메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있다. <br/>
자바스크립트의 `var` 키워드는 암묵적으로 초기화를 수행하므로 이러한 위험으로부터 안전하다.<br/>

변수를 포함하여 모든 식별자(함수, 클래스 등)를 사용하려면 반드시 선언이 필요하다. <br/>
선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러) 발생한다.<br/>

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```ts
console.log(count); // undefined
var count; // 변수 선언문
```

변수 선언문보다 변수를 참조하는 코드가 앞에 있다.<br/>
자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 콘솔에 찍는 코드가 먼저 실행되고 순차적으로 다음 줄에 있는 코드를 실행하게 된다.<br/>
따라서 `console.log(count);` 가 실행되는 시점에는 아직 count 변수의 선언이 실행되지 않았으므로 Reference Error가 발생할 것처럼 보인다. <br/>
하지만 참조 에러가 발생하지 않고 undefined가 출력된다.<br/>

```
WHY?
변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문
```

자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. <br/>
(변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다)<br/>
그리고 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.<br/>

즉, 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. <br/>
따라서 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있다.<br/>

=> 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 한다.<br/>
변수 선언뿐 아니라 `var`, `let`, `const`, `function`, `function\*`, `class` 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)은 호이스팅된다. <br/>
모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.<br/>

## 4.5 값의 할당

변수에 값을 할당(assignment)할때는 할당 연산자 `=`를 사용한다.

```ts
var count; // 변수 선언
count = 80; // 변수 할당
```

변수 선언과 값의 할당을 하나의 문(statement)로 단축하여 표현할 수도 있다.

```ts
var count = 80;
```

이 두 코드는 정확히 동일하게 동작한다.<br/>
즉 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.<br/>

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다. <br/>

```ts
console.log(count); // undefined

var count;
count = 80;

console.log(count); // 80
```

```ts
console.log(count); // undefined

var count = 80;

console.log(count); // 80
```

변수 선언이 런타임 이전에 먼저 실행되고 이때 이미 `undefined`로 초기화되어 있다.<br/>
count 변수에 값을 할당하면 count 변수의 값은 `undefined`에서 새롭게 할당한 숫자 값 80으로 변경(재할당)된다.<br/>

여기서 주의할 점은, 변수에 값을 할당할때는 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장하는 것이다.

## 4.6 값의 재할당

재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또 다시 할당하는 것을 말한다.

```ts
var count = 80;
count = 90; // 값의 재할당
```

var 키워드로 선언한 변수는 선언과 동시에 `undefined`로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당이다.<br/>

만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 **상수(constant)** 라고 한다. 상수는 단 한번만 할당할 수 있는 변수다.<br/>

## 4.7 식별자 네이밍 규칙

식별자(identifier)는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름을 말한다.<br/>
따라서 식별자는 다음과 같은 네이밍 규칙을 준수해야한다.

- 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있다
- 단, 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호($)로 시작해야한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다

```
[예약어] 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어
await, break, case, catch, class, const, continue, this, void, true, return.....
```

변수 이름도 식별자이므로 위 네이밍 규칙을 따라야한다. <br/>
변수는 쉼표(,)로 구분해 하나의 문에서 여러 개를 한번에 선언할 수 있지만, 가독성이 나빠지므로 권장하지는 않는다.

```ts
var person, $elem, _name, first_name, val1;
```

다음 식별자는 명명 규칙에 위배되므로 변수 이름으로 사용할 수 없다

```ts
var first-name; // Uncaught SyntaxError: Unexpected token '-'
var 1st; // Uncaught SyntaxError: Invalid or unexpected token
var this; // Uncaught SyntaxError: Unexpected token 'this'
```

자바스크립트는 대소문자를 구별하므로 다음 변수는 각각 별개의 변수다.

```ts
var firstname;
var firstName;
var FIRSTNAME:
```

변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야한다. 좋은 변수 이름은 코드의 가독성을 높인다.

```ts
var x = 3; // x 변수가 의미하는 바를 알 수 없다
var score = 100; // score 변수는 점수를 의미힌다
```

네이밍 컨벤션 (naming convention)은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정된 명명 규칙이다. <br/>
다음과 같은 4가지 유형의 네이밍 컨벤션이 자주 사용된다.

```ts
var firstName; // 카멜 케이스 (camelCase)
var first_name; // 스네이크 케이스 (snake_case)
var FirstName; // 파스칼 케이스 (PascalCase)

// 헝가리안 케이스 (typeHungarianCase)
var strFirstName;
var $elem = document.getElementById("myId");
var observable$ = fromEvent(document, "click");
```

일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고<br/>
생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.
